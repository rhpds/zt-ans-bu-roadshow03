:notoc:


# ‚ö° Operational Efficiency with Event-Driven Ansible

## üéØ Scenario 03: Operational Efficiency

### Introduction

Until now, you've focused primarily on technical automation - automating specific technical requirements that greatly benefit your technical teams. To unlock additional value from **Ansible automation**, you need to explore how it can orchestrate between systems and tools, acting as the organizational "glue" that connects different processes and teams.

This scenario demonstrates how to utilize advanced features of **Ansible Automation Platform** to reduce mean time to resolution (MTTR), prevent outages, and ultimately provide real business value to your organization through intelligent, event-driven automation.

![Scenario 3 Overview](/scenario3.png)

![Operational Challenge Details](/scenario0301.png)

---

## üîê Prerequisites

> ‚ö†Ô∏è **IMPORTANT:** This lab requires Red Hat account access for Red Hat Insights integration. If you don't have a Red Hat account, please register at https://developers.redhat.com/

![Red Hat Developer Portal](/dev-redhat.png)

![Registration Process](/reg-dev.png)

---

## üöÄ Lab Environment Setup

### Access Credentials

| **System** | **Username** | **Password** |
|------------|--------------|--------------|
| **Ansible Automation Platform** | admin | ansible123! |
| **ServiceNow** | aap-roadshow | Ans1ble123! |

### Background Context

Your streaming platform has benefited significantly from your automation journey. You can now provision, configure, and maintain infrastructure seamlessly. However, like most organizations, you still experience occasional failures that impact content delivery to customers.

> üí° **The Question:** Can you automate responses to everything? Let's find out...

---

## üß™ Lab Exercises

### Exercise 1: Simulating Application Failures

#### Understanding the Problem

Last week, your streaming service was disrupted due to a web application failure. It took hours to identify and resolve the issue after the fault occurred. While you hope this doesn't happen again, imagine how much time you could save with the ability to detect and respond to faults as soon as they happen.

#### ****Step 1: Verify Application Health****

1. Navigate to the **Web-App** tab
2. Verify that your application is working in the developer environment
3. Feel free to watch the latest episode of **The NC Office**

> üìù **NOTE:** This confirms the application is functioning correctly and provides entertainment while you work!

#### ****Step 2: Meet S.E.A.N - The Co-Worker Simulator****

To simulate issues accurately, you'll use a specialized testing tool called **S.E.A.N**:

- **S**: System Saboteur
- **E**: Error Magnet  
- **A**: Antisocial API
- **N**: Network Nullifier

**S.E.A.N** leverages another powerful feature of **Ansible Automation Platform**: *The API*

![S.E.A.N Co-Worker Simulator](/sean.png)

#### ****Step 3: Create API Access Token****

1. Select the hamburger menu icon
2. Navigate to **Access Management** ‚Üí **Users**
3. Select the **admin** user
4. Click on the **Tokens** tab
5. Click **Create token**

![AAP Token Creation Interface](/where-token.png)

**Token Configuration:**

| **Field** | **Value** |
|-----------|-----------|
| **OAuth application** | Leave blank |
| **Description** | API Access Token |
| **Scope** | Write |

6. Copy the generated token immediately

> ‚ö†Ô∏è **WARNING:** Store this token securely as it's required to authenticate S.E.A.N against the Ansible Automation Platform API. You won't be able to view it again after creation.

#### ****Step 4: Configure S.E.A.N****

1. Navigate to the **S.E.A.N** tab
2. When prompted for the token, right-click in the terminal and select "Paste"
3. Enter your copied token

Once authenticated, a menu of simulation options will appear.

![S.E.A.N Token Input](/token-sean.png)

#### ****Step 5: Simulate Application Failure****

1. Select option **1** to simulate web application configuration failure

> üìù **NOTE:** This will trigger an API call to Ansible Automation Platform, demonstrating how external systems can interact with your automation infrastructure.

#### ****Step 6: Monitor Automation Response****

1. Navigate to the **AAP** tab
2. Go to **Automation Execution** ‚Üí **Jobs**
3. Find the Ansible Job titled **Break Web-Application**

![Break Web Application Job](/break-web.png)

#### ****Step 7: Verify Application Failure****

1. Once the job completes, navigate to the **Web-App** tab
2. Refresh the page
3. You should see an error message indicating the service is no longer connecting

![Broken Application Display](/broken-app.png)

#### ****Step 8: Restore Application****

1. Return to the **S.E.A.N** tab
2. Select option **2** to restore the application configuration
3. Verify the restoration by checking:
   - Job status in **Automation Execution** ‚Üí **Jobs**
   - Application availability in the **Web-App** tab

---

### Exercise 2: Implementing Event-Driven Automation

#### Understanding Event-Driven Ansible

**S.E.A.N** has demonstrated how to break systems, but now you'll implement proactive automation to prevent future issues, saving time and money while allowing your technical team to rest easy.

#### ****Step 1: Access Automation Decisions****

1. Navigate to the **aap** tab
2. Select **Automation Decisions**
3. Click on **Rulebook Activations**

> üí° **TIP:** Event-Driven Ansible uses rulebooks to listen for specific events on your infrastructure and automatically respond to them.

![Rulebook Activations](/rules.png)

#### ****Step 2: Create Rulebook Activation****

1. Click **Create rulebook activation**
2. Configure with the following details:

**Rulebook Configuration:**

| **Field** | **Value** |
|-----------|-----------|
| **Name** | Web-App Event |
| **Description** | Rulebook to listen to configuration issues |
| **Organization** | Default |
| **Project** | Roadshow |
| **Rulebook** | Webapp.yml |
| **Decision Environment** | Web Server |
| **Credential** | AAP |
| **Restart Policy** | On failure |

3. Click **Create rulebook activation**
4. Return to **Rulebook Activations**
5. Wait until the rulebook shows a **Running** state

![Web App Rulebook Running](/web-app.png)

#### ****Step 3: Understanding Event Monitoring****

Your **Ansible Automation Platform** is now listening to events from your application server. Every event generated on this server becomes a source of information for your automation platform.

> üìù **NOTE:** Currently, you're monitoring for httpd service failures, but this could be expanded to watch for any specific events you want to track.

#### ****Step 4: Test Automated Remediation****

1. Navigate back to **S.E.A.N**
2. Select option **1** again to break the application
3. Immediately go to the **aap** tab
4. Monitor **Automation Execution** ‚Üí **Jobs**

You'll observe the following sequence:

1. ‚ö° The **Break Web-Application** template is triggered
2. ‚ö° Within seconds of completion, the **Restore Web-Application** template automatically starts
3. ‚ö° The issue is fixed automatically, reducing downtime significantly

#### ****Step 5: Analyze Automated Response****

1. Navigate into the **Break Web-Application** job run
2. Examine the job details

> üéØ **KEY INSIGHT:** You'll see that the httpd service was unable to restart after S.E.A.N made configuration changes. This failure is the trigger that Event-Driven Ansible used to automatically remediate the configuration and restore the service!

---

## üèóÔ∏è Technical Deep Dive

### Event-Driven Architecture Benefits

**Proactive Problem Resolution:**
- Automatic detection of service failures
- Immediate remediation without human intervention
- Reduced mean time to resolution (MTTR)

**Business Value:**
- Decreased downtime and customer impact
- Reduced operational overhead
- Improved service reliability and availability

**Scalability:**
- Monitor multiple services and applications
- Implement complex remediation workflows
- Integrate with existing monitoring and alerting systems

### API-Driven Automation

**External System Integration:**
- REST API enables third-party tool integration
- Secure token-based authentication
- Programmatic job execution and monitoring

**Use Cases:**
- Incident response automation
- Integration with monitoring tools
- Custom application workflows
- DevOps pipeline integration

---

## üíª Code Reference

### Event-Driven Rulebook Example

```yaml
---
- name: Web Application Monitoring
  hosts: all
  sources:
    - ansible.eda.journald:
        hostname: "{{ ansible_host }}"
        port: 5140
        transport: tcp
  rules:
    - name: Restart httpd on failure
      condition: event.message is match(".*httpd.*failed.*")
      action:
        run_job_template:
          name: "Restore Web-Application"
          organization: "Default"
```

### API Integration Example

```bash
# API Token Authentication
curl -X POST https://aap.example.com/api/v2/job_templates/123/launch/ \
  -H "Authorization: Bearer YOUR_TOKEN_HERE" \
  -H "Content-Type: application/json" \
  -d '{
    "extra_vars": {
      "target_host": "web-server-01"
    }
  }'
```

---
